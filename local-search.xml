<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java学习笔记—第四周—Number课件</title>
    <link href="/henry.github.io/2024/06/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Number%E8%AF%BE%E4%BB%B6/"/>
    <url>/henry.github.io/2024/06/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Number%E8%AF%BE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1>final关键字</h1><ol><li>有时候我们不希望子类重写父类中的方法，或者改变父类中的变量，可以使用final关键字，将其变为常量。</li><li>也可以在创建类的时候，在class关键字前加入final关键字，这样这个类就无法被extend</li><li>一般一个static final 变量名要大写，表明身份。</li><li>final变量要在声明时初始化，或者在构造器中初始化。</li><li>final类和抽象类是不同的：final类不能被继承，抽象类不能被实例化。</li></ol><h1>static关键字</h1><p>参考文章：<br><a href="https://blog.csdn.net/sophia__yu/article/details/83578934">https://blog.csdn.net/sophia__yu/article/details/83578934</a></p><ol><li><p>static变量，一般也称为类变量（class variable），具有static关键字的成员，一般在类被创建的时候就会建立一块内存区域，独属于类的内存，该类和其子类共同访问这块内存。</p><p>在类中，非static成员，一般在实例化时，会建立这些成员的副本，各实例自己管理该副本。</p><p>而static成员，所有类实例都会访问。</p><p>任意实例在改变这个静态成员时，所有对象对应的该成员都会被改变</p></li><li><p>static方法中只能使用static变量或者static方法，非static方法可以使用static成员</p></li><li><p>static还可以用于代码块，随类一同被建立</p></li><li><p>所有static修饰的内容，在类被创建时，同时建立</p></li><li><p>static无法应用于构造器，静态属于类，构造器属于对象<br>参考文章：<br><a href="https://www.cnblogs.com/java-friend/p/11750671.html">https://www.cnblogs.com/java-friend/p/11750671.html</a></p></li><li><p>通常我们可以同时使用static和final来修饰一个常量，所有对象都可以访问，并且无法修改常量</p></li></ol><h2 id="Math类">Math类</h2><ol><li>public final class Math，可以看到Math类是final的，无法被修改。</li><li>private Math( )，它的构造器是私有的，所以无法被实例化。</li><li>Math类中所有成员，包括所有变量和方法，都是static的。</li></ol><p><strong>提问：哪些类不能被实例化？</strong></p><p><strong>答案：抽象类，接口，具有private构造器的类。</strong></p><ol><li>Abstract classes and interfaces.</li><li>Classes with private constructors</li></ol><h1>Wrapper Classes包装类</h1><ol><li>包装类，当基本类型需要被当作对象使用时。</li><li>每个基本类型都有对应的包装类。</li><li>两个名字与基本类型不同的包装类：Integer, Character。</li></ol><h2 id="Autoboxing-自动包装">Autoboxing 自动包装</h2><p>待更新</p><h2 id="Static-Method-in-Wrappers">Static Method in Wrappers</h2><p>Wrappers有一些可以转换的方法：</p><p>接收字符串类型，返回一个特定的基本类型：</p><p>布尔类型与其它类型十分不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;10&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-type">Strign</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;true&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(str1);<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Double.parseDouble(str2);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(str3).booleanValue();<br></code></pre></td></tr></table></figure><p>以下这种情况，可以被编译，但无法运行，会报错：NumberFormatException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">anotherStr</span> <span class="hljs-operator">=</span> “ten”;<br><span class="hljs-type">int</span> <span class="hljs-variable">anotherInt</span> <span class="hljs-operator">=</span> Integer.parseInt(anotherStr);<br></code></pre></td></tr></table></figure><h2 id="Static-Imports">Static Imports</h2><p>当import某些包时，你也可以使用static关键字进行import，这样做后，使用包中类可以省类名，默认使用类中的成员，但会使得代码难以理解，无法辨认1成员出自哪些类：</p><p>待更新</p><h2 id="Wrapper-Classes-and-Number">Wrapper Classes and Number</h2><p>所有的包装类都是Number抽象类的子类，你可以构造一个Number对象，放入一个包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="一些其它常见问题">一些其它常见问题</h2><ol><li><p>什么时候使用包装类、number类，而不是基本数据类型？</p><ol><li>当方法期待一个对象参数时，通常用于处理数字集合。</li><li>当我们希望数值处为null时，只有当其为对象时，才可以为null，如果是基本数据类型，则一般为默认值。</li></ol></li><li><p>Number子类，即包装类，有一些常量，用来表示该数据类型的最大最小值：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Long.MIN_VALUE); → –<span class="hljs-number">2</span>^<span class="hljs-number">63</span><br></code></pre></td></tr></table></figure></li><li><p>可以使用class method to convert values to/from other primitive types, to/from strings，并且可以在不同数制下转换：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.toHexString(i);<br></code></pre></td></tr></table></figure></li><li><p>Which of these classes define immutable objects?<br>Character<br>Byte<br>Short<br>Object</p></li></ol><p>immutable objects：不可变的对象，实际上就是final类型</p><p>这几个中，包装类都是final类型</p><h2 id="包装类的常用方法">包装类的常用方法</h2><p>参考文章：<br><a href="http://t.csdnimg.cn/Waffj">http://t.csdnimg.cn/Waffj</a></p><h1>Recursion递归</h1><h2 id="Java递归方法中两个重要部分">Java递归方法中两个重要部分</h2><h3 id="Base-Case">Base Case</h3><p>Base Case是递归停止的条件，标明了递归的最简单情况，base case避免了无穷递归的情况。</p><h3 id="Recursive-Case">Recursive Case</h3><p>recursive case是method的一部分，是method调用自己的部分。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

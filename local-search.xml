<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java学习笔记—第四周-Exception Handling 异常处理</title>
    <link href="/henry.github.io/2024/06/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Exception-Handling-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/henry.github.io/2024/06/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Exception-Handling-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1>Run-Time Error Handling</h1><p>错误类型：</p><ol><li><p>系统自动抛出的异常</p><p>所有系统定义的编译和运行异常都可以由系统自动抛出，称为标准异常</p></li><li><p>语句抛出的异常<br>用户程序自定义的异常和应用程序特定的异常，必须借助throws 和 throw 语句来定义抛出异常。</p></li></ol><p>具体来说，有很多种不同的异常可能出现：</p><p>用户输入了非法数据，要打开的文件不存在或者没有权限，网络通信时连接中断，或者JVM内存溢出</p><h2 id="三种类型的异常">三种类型的异常</h2><ol><li><p>检查性异常</p><p>最具代表的检查性异常是<strong>用户错误或问题</strong>引起的异常，这些异常在编译时强制要求程序员处理。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</p><p>这类异常通常使用 <strong>try-catch</strong> 块来捕获并处理异常，或者在方法声明中使用 <strong>throws</strong> 子句声明方法可能抛出的异常。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能会抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-comment">// 处理异常的代码</span><br>&#125;<br><span class="hljs-comment">//or或者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 可能会抛出IOException的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行时异常</p><p>这些异常在编译时不强制要求处理，通常是由程序中的错误引起的，例如 NullPointerException、ArrayIndexOutOfBoundsException 等，这类异常可以选择处理，但并非强制要求。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能会抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>    <span class="hljs-comment">// 处理异常的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>错误</p><p>错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p></li></ol><p>要么尝试捕获运行时错误，要么就是尝试声明不要捕获。</p><p>Java提供了以下的关键字来支持异常处理：</p><ul><li><strong>try</strong>：用于包裹可能会抛出异常的代码块。</li><li><strong>catch</strong>：用于捕获异常并处理异常的代码块。</li><li><strong>finally</strong>：用于包含无论是否发生异常都需要执行的代码块。</li><li><strong>throw</strong>：用于手动抛出异常。</li><li><strong>throws</strong>：用于在方法声明中指定方法可能抛出的异常。</li><li><strong>Exception</strong>类：是所有异常类的父类，它提供了一些方法来获取异常信息，如 <strong>getMessage()、printStackTrace()</strong> 等。</li></ul><h2 id="怎么处理异常？">怎么处理异常？</h2><h3 id="2-1JVM默认处理异常的方式">2.1JVM默认处理异常的方式</h3><ol><li>如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤：</li></ol><ul><li>把异常的名称，错误原因及异常出现的位置等信息输出在了控制台</li><li>程序停止执行</li></ul><h3 id="2-2try-catch方式">2.2try-catch方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>可能出现异常的代码; <br>&#125; <span class="hljs-keyword">catch</span>(异常类名 变量名) &#123;<br> 异常的处理代码; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>执行流程</li></ul><ol><li>程序从 try 里面的代码开始执行</li><li>出现异常，就会跳转到对应的 catch 里面去执行，进行处理</li><li>执行完毕之后，程序还可以继续往下执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo01</span> &#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>System.out.println(<span class="hljs-string">&quot;开始&quot;</span>); method(); <br>System.out.println(<span class="hljs-string">&quot;结束&quot;</span>); <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <br>System.out.println(arr[<span class="hljs-number">3</span>]); <br>System.out.println(<span class="hljs-string">&quot;这里能够访问到吗&quot;</span>); <br>&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123; <br><span class="hljs-comment">// System.out.println(&quot;你访问的数组索引不存在，请回去修改为正确的索引&quot;); </span><br>e.printStackTrace(); <br>&#125; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3throw方式">2.3throw方式</h3><p><strong>throw</strong> 关键字用于在当前方法中抛出一个异常。</p><p>通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 <strong>throw</strong> 关键字抛出异常，以告知调用者当前代码的执行状态。</p><p>即：当程序运行不满足程序员要求的格式时，可以使用throw抛出异常，</p><h2 id="throws和throw的区别">throws和throw的区别</h2><h3 id="throws">throws</h3><p>用在方法声明后面，跟的是异常类名<br>表示抛出异常，由该方法的调用者来处理<br>表示出现异常的一种可能性，并不一定会发生这些异常</p><h3 id="throw">throw</h3><p>用在方法体内，跟的是异常对象名<br>表示抛出异常，由方法体内的语句处理<br>执行 throw 一定抛出了某种异常</p><p>总结：</p><ol><li>throw 是语句抛出一个异常；throws 是方法抛出一个异常；</li><li>throw语法：throw &lt;异常对象&gt;</li><li>throws语法：[&lt;修饰符&gt;]&lt;返回值类型&gt;&lt;方法名&gt;（[&lt;参数列表&gt;]）[throws&lt;异常类&gt;]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 调用声明抛出 Checked 异常的方法，要么显式捕获该异常</span><br><span class="hljs-comment">// 要么在 main 方法中再次声明抛出</span><br>throwChecked(-<span class="hljs-number">3</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>System.out.println(e.getMessage());<br>&#125;<br><span class="hljs-comment">// 调用声明抛出 Runtime 异常的方法既可以显式捕获该异常</span><br><span class="hljs-comment">// 也可不理会该异常</span><br>throwRuntime(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwChecked</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//自行抛出 Exception 异常</span><br><span class="hljs-comment">//该代码必须处于 try 块里，或处于带 throws 声明的方法中</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;a 的值大于 0，不符合要求&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwRuntime</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br><span class="hljs-keyword">if</span>( a &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 自行抛出 RuntimeException 异常，既可以显式捕获该异常</span><br><span class="hljs-comment">// 也可完全不理会该异常，把该异常交给该方法调用者处理</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;a 的值大于 0，不符合要求&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么要抛出异常，什么时候抛出异常？">为什么要抛出异常，什么时候抛出异常？</h3><ul><li>为什么要捕获异常？<br>编译时程序可能会出现异常，如果出现异常程序就会中断，但是如果捕获异常，做出处理，程序就可以运行下去</li><li>抛出异常和捕获异常的区别？</li></ul><ol><li>抛出异常：没有办法将具体的异常打印出来，不做任何处理；程序中断。</li><li>捕获异常：如果程序出现了异常，就能够详细的打印什么原因导致了异常，并且能够做出相应的处理，显示详细的日志，程序不会中断。</li></ol><h2 id="再详说try-catch-块">再详说try/catch 块</h2><ol><li><p>当程序运行，JVM会尝试执行try块中所有语句，</p><p>若其中某个语句throws an exception，那么：</p><p>对应的catch块将被执行，</p><p>或者，</p><p>该代码所在的方法本身将会抛出异常</p></li><li><p>try/catch块后面，也会有finally块，通常用于做异常处理之后的最后工作，例如关闭文件等</p></li></ol><h3 id="try-catch-finally块语法">try/catch/finally块语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//会抛出异常的代码</span><br>&#125;<br><span class="hljs-keyword">catch</span>(E1 e1)&#123;<br><span class="hljs-comment">//处理E1的代码</span><br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">catch</span>(En en)&#123;<br><span class="hljs-comment">//处理En的代码</span><br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">//code to tidy up: close files, etc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个try代码块后面跟随有多个catch，这种情况叫做多重捕获：</p><p>保护代码中发生异常，异常会被抛给第一个catch块。</p><p>如果抛出异常的数据类型与E1匹配，那么该异常在这里就会被捕获。</p><p>如果不匹配，就会传递给下一个catch块，</p><p>如此，直到异常被捕获或者通过所有的catch块</p><p>try-catch的模式，导致局部变量可以没有初始化，也正常存在，异常被捕获，但是不做对应初始化的操作，程序也不会退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> foo;<br><span class="hljs-keyword">try</span> &#123;<br> <span class="hljs-comment">// ...</span><br> foo = getResults();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// ... &#125;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> foo; <span class="hljs-comment">// HERE!</span><br><br><span class="hljs-comment">//Partial solution:</span><br><span class="hljs-type">int</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br> <span class="hljs-comment">// ...</span><br> foo = getResults();<br> <span class="hljs-type">int</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> foo;<br> <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// ... &#125;</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>所有抛出异常的代码块，必须包含在一个抛出异常的方法中吗？</p><p>不是的，对于检查异常（checked exception），必须在方法签名中声明，使用’throws‘关键字，这些异常是程序正常运行中可以预见的异常。对于非检查异常（unchecked exception）不需要在方法签名中声明，也不需要强制捕获处理。</p><h1>Creating Exception Classes</h1><p>可以创建自己的异常类，可以像正常的类一样使用，但是必须继承Exception类，要在构造器中调用父类的构造器。</p><p>自定义异常类，可以在该自定义异常类中对异常警告进行自定义。</p><h2 id="Understanding-Stack-Trace-Messages">Understanding Stack Trace Messages</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>statement1;<br>statement2;<br>statement3;<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception1 ex1) &#123; &#125;<br><span class="hljs-keyword">catch</span> (Exception2 ex2) &#123; &#125;<br>statement4;<br></code></pre></td></tr></table></figure><p>这段代码中，假设s2会造成异常，请问：</p><ol><li><p>s3会执行吗？</p></li><li><p>如果异常没有被捕获，s4会执行吗？</p></li><li><p>异常被其中一个catch捕获，s4会执行吗？</p></li></ol><p>答案：</p><ul><li><code>statement3</code>不会执行，s2抛出异常后，会直接跳转到catch块中</li><li>如果<code>try</code>块中的异常没有被<code>catch</code>块捕获，<code>statement4</code>不会执行。</li><li>如果<code>try</code>块中的异常被某个<code>catch</code>块捕获并处理，<code>statement4</code>会执行。</li></ul><p>为什么没有被catch捕获s4就不会执行？</p><p>在Java中，如果一个异常没有被捕获并处理，程序的正常控制流会被中断，异常会沿着调用栈向上传播，直到被某个合适的异常处理程序捕获或者导致程序终止。这就是为什么没有被捕获的异常会导致<code>statement4</code>不执行的原因。具体原因如下：</p><h3 id="异常传播机制"><strong>异常传播机制</strong></h3><ol><li><strong>异常抛出</strong>：当在<code>try</code><strong>块中抛出一个异常时，程序会立即停止执行</strong><code>try</code><strong>块中的剩余代码。</strong></li><li><strong>寻找处理程序</strong>：<strong>程序会检查是否有与抛出异常类型匹配的</strong><code>catch</code><strong>块。如果找到一个匹配的</strong><code>catch</code><strong>块，控制流会转移到这个</strong><code>catch</code><strong>块，并执行其中的代码。</strong></li><li><strong>未匹配处理程序</strong>：<strong>如果没有找到匹配的</strong><code>catch</code><strong>块，异常会沿着调用栈向上传播。传播过程会一直持续到找到合适的异常处理程序或最终到达Java虚拟机（JVM）。</strong></li><li><strong>程序终止</strong>：<strong>如果异常传播到JVM而没有被捕获，JVM会终止程序，并打印异常的堆栈跟踪信息。</strong></li></ol><h3 id="示例代码分析"><strong>示例代码分析</strong></h3><p>让我们用示例代码详细说明这一过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<br><span class="hljs-keyword">try</span> &#123;<br>    statement1;<br>    statement2;<br>    statement3;<br>&#125; <span class="hljs-keyword">catch</span> (Exception1 ex1) &#123;<br>    <span class="hljs-comment">// 处理Exception1</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception2 ex2) &#123;<br>    <span class="hljs-comment">// 处理Exception2</span><br>&#125;<br>statement4;<br><br></code></pre></td></tr></table></figure><p>假设在<code>try</code>块中抛出了一个未被捕获的异常：</p><ol><li><strong>异常抛出前</strong>：<code>statement1</code>和<code>statement2</code>顺利执行。</li><li><strong>异常抛出</strong>：<code>statement3</code>抛出了<code>Exception3</code>，而<code>Exception3</code>没有匹配的<code>catch</code>块。</li><li><strong>控制流中断</strong>：由于没有匹配的<code>catch</code>块，异常沿着调用栈向上传播。<code>try</code>块中的剩余代码（包括<code>statement3</code>之后的代码）不会执行。</li><li><strong>异常传播到调用者</strong>：如果当前方法没有处理异常，异常会继续向上传播到调用该方法的地方。</li><li><strong>JVM处理异常</strong>：如果异常最终传播到JVM，程序会终止，<code>statement4</code>永远不会执行。</li></ol><h3 id="捕获异常的情况"><strong>捕获异常的情况</strong></h3><p>当异常被捕获时，程序的控制流如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<br><span class="hljs-keyword">try</span> &#123;<br>    statement1;<br>    statement2;<br>    statement3;<br>&#125; <span class="hljs-keyword">catch</span> (Exception1 ex1) &#123;<br>    <span class="hljs-comment">// 处理Exception1</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception2 ex2) &#123;<br>    <span class="hljs-comment">// 处理Exception2</span><br>&#125;<br>statement4;<br><br></code></pre></td></tr></table></figure><p>假设**<code>statement3</code>抛出了一个被捕获的<code>Exception1</code>：</p><ol><li><strong>异常抛出前</strong>：<code>statement1</code>和<code>statement2</code>顺利执行。</li><li><strong>异常抛出</strong>：<code>statement3</code>抛出<code>Exception1</code>。</li><li><strong>控制流转移</strong>：程序找到匹配的<code>catch (Exception1 ex1)</code>块，控制流转移到该块并执行处理代码。</li><li><strong>异常处理后</strong>：<code>catch</code>块执行完后，程序继续执行<code>try-catch</code>块后的代码。</li><li><strong>继续执行</strong>：<code>statement4</code>会执行，因为异常已被处理。</li></ol><h3 id="总结"><strong>总结</strong></h3><ul><li><strong>未捕获异常</strong>：导致控制流中断，程序终止，<code>statement4</code>不执行。</li><li><strong>捕获异常</strong>：异常被处理后，程序继续执行，<code>statement4</code>会执行。</li></ul><p>这种行为确保异常处理的集中和清晰，同时避免程序在未处理异常情况下继续执行，可能导致不可预测的行为和错误。</p><h1>Assertions断言</h1><p><a href="http://t.csdnimg.cn/quJMl">http://t.csdnimg.cn/quJMl</a></p><p>断言，是一种有效检查和调试的工具，通过断言，我们可以验证程序的逻辑和假设，确保程序在运行时达到预期的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AssertionExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> x &gt; <span class="hljs-number">0</span> : <span class="hljs-string">&quot;x必须大于0&quot;</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;断言通过&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>断言条件，x&gt;0，如果不满足就会触发断言错误，抛出AssertionError异常。如果满足，将会输出“断言通过“的信息</p><h2 id="启用和禁用断言">启用和禁用断言</h2><p>默认情况下，JVM会禁用断言功能</p><p>启用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java -ea AssertionExample<span class="hljs-comment">//在命令行中输入，后面是类名</span><br>java -ea <span class="hljs-keyword">package</span> class<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>你必须先编译java文件后再启用断言</p><p>并且必须通过命令行来直接执行断言判断，运行java类是无效的</p><p>禁用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java -da AssertionExample<br>java -da <span class="hljs-keyword">package</span> class<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记—第四周—Number课件</title>
    <link href="/henry.github.io/2024/06/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Number%E8%AF%BE%E4%BB%B6/"/>
    <url>/henry.github.io/2024/06/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Number%E8%AF%BE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1>final关键字</h1><ol><li>有时候我们不希望子类重写父类中的方法，或者改变父类中的变量，可以使用final关键字，将其变为常量。</li><li>也可以在创建类的时候，在class关键字前加入final关键字，这样这个类就无法被extend</li><li>一般一个static final 变量名要大写，表明身份。</li><li>final变量要在声明时初始化，或者在构造器中初始化。</li><li>final类和抽象类是不同的：final类不能被继承，抽象类不能被实例化。</li></ol><h1>static关键字</h1><p>参考文章：<br><a href="https://blog.csdn.net/sophia__yu/article/details/83578934">https://blog.csdn.net/sophia__yu/article/details/83578934</a></p><ol><li><p>static变量，一般也称为类变量（class variable），具有static关键字的成员，一般在类被创建的时候就会建立一块内存区域，独属于类的内存，该类和其子类共同访问这块内存。</p><p>在类中，非static成员，一般在实例化时，会建立这些成员的副本，各实例自己管理该副本。</p><p>而static成员，所有类实例都会访问。</p><p>任意实例在改变这个静态成员时，所有对象对应的该成员都会被改变</p></li><li><p>static方法中只能使用static变量或者static方法，非static方法可以使用static成员</p></li><li><p>static还可以用于代码块，随类一同被建立</p></li><li><p>所有static修饰的内容，在类被创建时，同时建立</p></li><li><p>static无法应用于构造器，静态属于类，构造器属于对象<br>参考文章：<br><a href="https://www.cnblogs.com/java-friend/p/11750671.html">https://www.cnblogs.com/java-friend/p/11750671.html</a></p></li><li><p>通常我们可以同时使用static和final来修饰一个常量，所有对象都可以访问，并且无法修改常量</p></li></ol><h2 id="Math类">Math类</h2><ol><li>public final class Math，可以看到Math类是final的，无法被修改。</li><li>private Math( )，它的构造器是私有的，所以无法被实例化。</li><li>Math类中所有成员，包括所有变量和方法，都是static的。</li></ol><p><strong>提问：哪些类不能被实例化？</strong></p><p><strong>答案：抽象类，接口，具有private构造器的类。</strong></p><ol><li>Abstract classes and interfaces.</li><li>Classes with private constructors</li></ol><h1>Wrapper Classes包装类</h1><ol><li>包装类，当基本类型需要被当作对象使用时。</li><li>每个基本类型都有对应的包装类。</li><li>两个名字与基本类型不同的包装类：Integer, Character。</li></ol><h2 id="Autoboxing-自动包装">Autoboxing 自动包装</h2><p>待更新</p><h2 id="Static-Method-in-Wrappers">Static Method in Wrappers</h2><p>Wrappers有一些可以转换的方法：</p><p>接收字符串类型，返回一个特定的基本类型：</p><p>布尔类型与其它类型十分不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;10&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-type">Strign</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;true&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(str1);<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Double.parseDouble(str2);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(str3).booleanValue();<br></code></pre></td></tr></table></figure><p>以下这种情况，可以被编译，但无法运行，会报错：NumberFormatException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">anotherStr</span> <span class="hljs-operator">=</span> “ten”;<br><span class="hljs-type">int</span> <span class="hljs-variable">anotherInt</span> <span class="hljs-operator">=</span> Integer.parseInt(anotherStr);<br></code></pre></td></tr></table></figure><h2 id="Static-Imports">Static Imports</h2><p>当import某些包时，你也可以使用static关键字进行import，这样做后，使用包中类可以省类名，默认使用类中的成员，但会使得代码难以理解，无法辨认1成员出自哪些类：</p><p>待更新</p><h2 id="Wrapper-Classes-and-Number">Wrapper Classes and Number</h2><p>所有的包装类都是Number抽象类的子类，你可以构造一个Number对象，放入一个包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="一些其它常见问题">一些其它常见问题</h2><ol><li><p>什么时候使用包装类、number类，而不是基本数据类型？</p><ol><li>当方法期待一个对象参数时，通常用于处理数字集合。</li><li>当我们希望数值处为null时，只有当其为对象时，才可以为null，如果是基本数据类型，则一般为默认值。</li></ol></li><li><p>Number子类，即包装类，有一些常量，用来表示该数据类型的最大最小值：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Long.MIN_VALUE); → –<span class="hljs-number">2</span>^<span class="hljs-number">63</span><br></code></pre></td></tr></table></figure></li><li><p>可以使用class method to convert values to/from other primitive types, to/from strings，并且可以在不同数制下转换：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.toHexString(i);<br></code></pre></td></tr></table></figure></li><li><p>Which of these classes define immutable objects?<br>Character<br>Byte<br>Short<br>Object</p></li></ol><p>immutable objects：不可变的对象，实际上就是final类型</p><p>这几个中，包装类都是final类型</p><h2 id="包装类的常用方法">包装类的常用方法</h2><p>参考文章：<br><a href="http://t.csdnimg.cn/Waffj">http://t.csdnimg.cn/Waffj</a></p><h1>Recursion递归</h1><h2 id="Java递归方法中两个重要部分">Java递归方法中两个重要部分</h2><h3 id="Base-Case">Base Case</h3><p>Base Case是递归停止的条件，标明了递归的最简单情况，base case避免了无穷递归的情况。</p><h3 id="Recursive-Case">Recursive Case</h3><p>recursive case是method的一部分，是method调用自己的部分。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
